const
  {Carcateres de controle do protocolo de comunicação}
  cNUL   = Chr($00);  {NULl}
  cSOH   = Chr($01);  {STart of teXt}
  cSTX   = Chr($02);  {STart of teXt}
  cETX   = Chr($03);  {End of TeXt}
  cEOT   = Chr($04);  {End Of Transmission}
  cENQ   = Chr($05);  {ENQuiry}
  cACK   = Chr($06);  {ACKnowledge}
  cBEL   = Chr($07);  {BELl}
  cCR_   = Chr($0D);  {Carriage return}
  cLF_   = Chr($0A);  {Line feed}
  cDLE   = Chr($10);  {Data Link Escape}
  cXON   = Chr($11);  {Xon}
  cXOF   = Chr($13);  {Xoff}
  cNAK   = Chr($15);  {Not AcKnowledge}
  cETB   = Chr($17);  {End of (intermediate) Text Block}
  cESC   = Chr($1B);  {Escape}
  cSFR   = Chr($7E);  {Start of FRame (frame delimiter)}
  cESF   = Chr($7D);  {Escape control}

  bNUL   =     $00 ;  {NULl}
  bSOH   =     $01 ;  {Start Of Heading}
  bSTX   =     $02 ;  {STart of teXt}
  bETX   =     $03 ;  {End of TeXt}
  bEOT   =     $04 ;  {End Of Transmission}
  bENQ   =     $05 ;  {ENQuiry}
  bACK   =     $06 ;  {ACKnowledge}
  bBEL   =     $07 ;  {BELl}
  bCR_   =     $0D ;  {Carriage return}
  bLF_   =     $0A ;  {Line feed}
  bDLE   =     $10 ;  {Data Link Escape}
  bXON   =     $11 ;  {Xon}
  bXOF   =     $13 ;  {Xoff}
  bNAK   =     $15 ;  {Not AcKnowledge}
  bETB   =     $17 ;  {End of (intermediate) Text Block}
  bESC   =     $1B ;  {Escape}
  bSFR   =     $7E ;  {Start of FRame (frame delimiter)}
  bESF   =     $7D ;  {Escape control}

AQR_teEventosCAN = (

AQR_eProduzindo = 0,
AQR_eManobrando,
AQR_eParado,
AQR_eArremate,
AQR_eEsvaziando,
AQR_eDesembuchando,
AQR_eOutros,

//Marca quantidade de eventos existentes
AQR_eQuantEventosCAN

);

//Estados da interface da automação de colheita:
AUT_teEstadoAuto = (

eaInativo,     //Estado inativo - processo parado.
eaCicloInicio, //Aguardando início do ciclo de carga.
eaCicloTrans,  //Estado de transição para bloquear comunicação.
//eaEtapaInicio, //Aguardando início de etapa de carga.
//eaEtapaTrans,  //Estado de transição para bloquear comunicação.
//eaEtapaFim,    //Aguardando fim de etapa de carga.
eaCicloFim,    //Aguardando fim de ciclo de carga.
eaTransbordo,  //Aguardando transbordo.
eaAtivo,       //Aguardando comandos externos (caminhão ou pb).
eaOcupado      //Operador ocupando o sistema (caminhão ou pb).

);

AUT_tePersonalidades = (

AUT_ePersonGenerico         = $0000,
AUT_ePersonPL               = $7FFF,
AUT_ePersonColhedora        = $8000,
AUT_ePersonTransbordo       = $8001,
AUT_ePersonCaminhaoPicada   = $8003,
AUT_ePersonCaminhaoApoio    = $8004,
AUT_ePersonPLM              = $8007,
AUT_ePersonPLM_Mae          = $8008,
AUT_ePersonETD              = $8009

);

//Estrutura para identificação de CBA de origem ou destino de pacote:
M2M_tsId = record

dAddHi        : Longword;             //Endereço do módulo tem 8 bytes!
dAddLo        : Longword;             //ATENÇÃO: BIG ENDIAN!!!!
abCodVeic     : TabCod6;              //Código do veículo
abIdCBA       : TabCod6;              ///ID-CBA - número de série de hardware
wAplicacaoID  : AUT_tePersonalidades; //Aplicação do veiculo acima
bVersaoFW     : Byte;                 //Versão de firmware do m2m
eEstadoCEC    : AUT_teEstadoAuto;     //Estado do CEC
bEstadoCiclo  : Byte;                 //Numero do estado do ciclo automático
eEstadoMaquina: AQR_teEventosCAN;     //Estado da maquina

end;

//Estrutura para identificação de CBA com posição:
M2M_tsIdPos = record

sId          : M2M_tsId; //Identificação do CBA.
dDataHora    : Longword; //Data/hora de sistema.
gLatitude    : Double;   //Latitude no início do registro.
gLongitude   : Double;   //Longitude no início do registro.
dVel         : Longword; //Módulo da velocidade.
lLatitudeRef : Longint;  //Latitude em relação a sua referência
lLongitudeRef: Longint;  //Longitude em relação a sua referência
lHeading     : Longint;  //Direção.
dTamanho     : Longword; //Tamanho do Veículo + Implemento.
abReservado  : array[0..3] of byte; //Para futuras aplicações.
end;

//Estrutura de um pacote de identificação de CBA (BEL):
M2M_tsPacoteBEL = record

//Este é um pacote para broadcast, sem destino específico.
sIdPos      : M2M_tsIdPos;          //Identificação com posição.
abMotorista : array[0..11] of Byte; //Identificação do operador.

end;

